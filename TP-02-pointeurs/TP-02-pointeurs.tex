\documentclass[a4paper,11pt]{article}

\input{enteteSujetTP.tex}

\emph{Note : Dans ce TP et tous les suivants, organisez vos programmes en fonctions. Essayez d’écrire des fonctions réutilisables et réutilisez les chaque fois que l’occasion se présente.}

\begin{center}
{\Large\textbf{Tableaux, structures et pointeurs}}
\end{center}

\begin{enumerate}

\item Ecrire et tester une fonction \texttt{echangeContenu} qui interverti le contenu de deux variables entières. Pour illustrer le traitement réalisé par cette fonction, supposons que l’on dispose de deux variables entières: $a$ initialisée à 10 et $b$ initialisée à 20. Après l’appel, $a$ aura pour valeur 20 et $b$ sera égale à 10. La fonction \texttt{echangeContenu} ne retourne rien. Elle a en revanche deux paramètres. A vous de déterminer leurs types.

% \item \textbf{Tableaux "convexes"}\\
% 	Ecrire une fonction \texttt{bool estConvexe(bool tab[],int length)} indiquant si un tableau à une dimension dont les éléments sont des booléens (le type \texttt{bool} est founir par \texttt{stdbool.h}) est \emph{convexe}. Un tableau est \emph{convexe} si tous les éléments du tableau ayant la valeur \texttt{true} sont consécutifs. Attention, le tableau est circulaire c'est-à-dire que les première et dernière cases du tableau sont considérées adjacentes. Par exemple:

% 	T1=(false,true,true,false,false) est convexe

% 	T2=(true,true,false,false,true) est convexe car tableau circulaire

% 	T3=(true,true,false,true,false) n'est pas convexe

\item \textbf{Matrices}\\
Écrire un programme qui permet de multiplier deux matrices carrées de taille 5. Vous pouvez définir cette taille comme une constante pré-processeur (cf. ci-dessous \texttt{SIZE}).
\begin{lstlisting}[style=csource]
#include <stdint.h>
#include <stdlib.h>

#define SIZE 5

int main(void) {
   //matrices en ligne * colonne
   int64_t matrice1[][SIZE]={{1,2,3,4,5},{1,2,3,4,5},{1,2,3,4,5},{1,2,3,4,5},{1,2,3,4,5}};
   int64_t matrice2[][SIZE]={{6,7,8,9,10},{6,7,8,9,10},{6,7,8,9,10},{6,7,8,9,10},{6,7,8,9,10}};
   int64_t matriceResultat[SIZE][SIZE];

   matrix_mult(matriceResultat,matrice1,matrice2);
   matrix_print(matriceResultat);

   return EXIT_SUCCESS;
}
\end{lstlisting}

\medskip

\begin{enumerate}

	\item Écrire les fonctions \texttt{matrix\_mult} et \texttt{matrix\_print} pour faire fonctionner la fonction \texttt{main} ci-dessus. Utilisez des tableaux. N'utilisez \textbf{pas} de pointeurs pour l'instant.
	Notez que \texttt{matrix\_mult} prend 3 paramètres dont le premier est la matrice résultat calculée.

 Rappel : Soit A, B et C des matrices telles que $C=A.B$. Le produit de deux matrices $A.B$ ne peut se définir que si le nombre de colonnes de $A$ est égal au nombre de lignes de $B$.

\begin{math}
\left(\begin{array}{ccc}
a_{11} & \dots & a_{1n}\\
\vdots & \ddots & \vdots\\
a_{m1} & \dots & a_{mn}
\end{array}\right)
.
\left(\begin{array}{ccc}
b_{11} & \dots & b_{1q}\\
\vdots & \ddots & \vdots\\
b_{p1} & \dots & b_{pq}
\end{array}\right)
=
\left(\begin{array}{ccc}
 c_{11} & \dots & c_{1q}\\
\vdots & \ddots & \vdots\\
c_{m1} & \dots & c_{mq}
\end{array}\right) \text{où} \left\{\begin{array}{l}
n=p \\
c_{ij}=\sum_{k=1}^{n} a_{ik}*b_{kj}
\end{array}\right.
\end{math}

\item Que pensez-vous de la fonction \texttt{mult\_matrice} en terme de réutilisation?

\item Comment feriez-vous pour généraliser ces deux fonctions pour des tailles quelconques de matrices ?
	On continue à supposer que l'initialisation des matrices est faite directement dans le \texttt{main}.

\end{enumerate}

\item \textbf{Manipuler des dates}

 % et calcule le numéro du jour dans l’année (ex : le 12/2/200 est le 43ème jour de l’année) si la date est valide (i.e. rejeter des date comme 43/15/1990). Bien entendu, il faut prendre en compte les années bissextiles (variation du nombre de jours de février). Le détail de ce que vous devez réaliser est présenté dans les deux paragraphes qui suivent.
\begin{enumerate}
	\item Définir les types :
		\begin{itemize}
			\item \texttt{Mois} représente les mois avec une énumération (cf. cours)
			\item \texttt{Date} représente une date avec une structure (cf. cours)
		\end{itemize}


\item Dans la fonction \texttt{main}, ajouter le code suivant:

\begin{lstlisting}[style=csource,backgroundcolor=\color{white},rulecolor=\color{white}] %skip

   Date d;
   initialiseDate(&d); //£\codecomment{Pourquoi a t-on ajouté un }\&\codecomment{?}£
   afficheDate(&d);
\end{lstlisting}
   Ecrivez le code des 2 fonctions:
   \begin{itemize}
      \item \texttt{initialiseDate} qui initialise une date dont l'adresse a été passée en paramètre en utilisant des \texttt{scanf}
      \item \texttt{afficheDate} qui affiche une date dont l'adresse a été passée en paramètre
   \end{itemize}

\item Dans la fonction \texttt{main}, ajouter le code suivant:
\begin{lstlisting}[style=csource,backgroundcolor=\color{white},rulecolor=\color{white}] %skip

   Date d;
   d = creerDateParCopie();
   afficheDate(&d);
\end{lstlisting}
   Ecrivez le code de la fonction \texttt{creerDateParCopie} qui doit également créer et initialiser une date en utilisant des \texttt{scanf}

\item Dans la fonction \texttt{main}, ajouter le code suivant:
\begin{lstlisting}[style=csource,backgroundcolor=\color{white},rulecolor=\color{white}] %skip

   Date *date;
   date = newDate();
   afficheDate(date);
   //...
   free(date);
\end{lstlisting}
Ecrivez le code de la fonction \texttt{newDate} qui créé une Date retourne son adresse (cf. Cours 3 \texttt{malloc}).
N'oubliez pas de restituer (\texttt{free}) la mémoire allouée dans ce cas.

   \item Comparer ces 3 fonctions. Quelle version (\texttt{initialiseDate}, \texttt{creerDateParCopie} ou \texttt{newDate}) ne devrait pas être utilisée et pourquoi?


	\item (\emph{bonus}) Définir les fonctions suivantes:
\begin{itemize}
\item \texttt{unsigned int nbreJours(Mois mois, unsigned int annee)} : retourne le nombre de jours du mois de l'années correspondante.
\item \texttt{bool dateValide(Date uneDate)} : indique si \texttt{uneDate} est valide ou non
\item \texttt{unsigned int jourDansAnnee(Date uneDate)} : retourne le numéro du jour dans l’année correspondante à la date donnée en paramètre.

\end{itemize}
\end{enumerate}

\item Re-faire l'exercice Matrice avec des \texttt{malloc/free} pour gérer des matrices de taille variable.

\begin{lstlisting}[style=csource,backgroundcolor=\color{white},rulecolor=\color{white}] %skip

Matrice *A, *B, *C;
Matrice *AmultB;

A = creer(1, 2, 3); // valeurInitiale, nbreLignes, nbreColonnes
B = creer(1, 3, 3);
initialiserLigne(2, 1, A);
initialiserLigne(2, 2, B);

C = multiplier(A, B);
\end{lstlisting}

\end{enumerate}

\section*{Bonus}

\begin{enumerate}
\item Faire "beer-song" sur \url{exercism.org} (string, array, \texttt{malloc/free})

% \item \texttt{bool anneeBissextile(unsigned int annee)} : retourne true si l’année est bissextile (29 jours dans le mois de février) et 0 sinon. Une année est bissextile dans 2 cas: si elle n’est pas séculaire (n’est pas divisible par 100) et elle est divisible par 4 ou si elle est séculaire et divisible par 400.
\item Fractions rationnelles et sommes harmoniques\\
On représente une fraction rationnelle ($\frac{x}{y}$) par un type enregistrement (\texttt{struct}) ayant deux champs entiers: \texttt{numerateur} et \texttt{denominateur}.
\begin{enumerate}
\item Écrire une fonction $simplifie$ qui, étant donné une fraction rationnelle (créer un type !), a pour résultat la fraction irréductible correspondante.
Par exemple : $\frac{45}{60}=\frac{3}{4}$.
\item Écrire une fonction permettant d'additionner deux fractions rationnelles ; la fraction obtenue devra être irréductible.
\item Écrire une fonction qui étant donné $N$, un entier positif, calcule :
$$H(N)=1+\frac{1}{2}+\frac{1}{3}+ ... + \frac{1}{N}$$
Le résultat doit être donné sous la forme d'une fraction irréductible.
\end{enumerate}

\end{enumerate}




% \newpage
% \begin{center}
%    {\large \textbf{Bonus}}
% \end{center}
% \smallskip
%
%    \item Ecrire (et tester) la fonction \texttt{lireEntier} qui retourne un nombre entier donné par l’utilisateur (\texttt{scanf}). Ce nombre doit être à l’intérieur d’un intervalle dont les bornes sont données en paramètre de la fonction. L’utilisateur est sollicité pour donner le nombre jusqu'à ce que dernier soit compris dans l’intervalle donné.
% Signature de la fonction :
%
% \texttt{int lireEntier(char message[], int borneInf, int borneSup)}
%
% Le paramètre \emph{message} est une chaîne de caractères affichée avant les bornes de l’intervalle avant chaque saisie. Exemple d’affichage :
%
% \texttt{Veuillez donner un mois [1-12] :}
%
% Dans cet exemple, message correspond à \emph{"Veuillez donner un mois"} Le reste de l’affichage est déduit des bornes de l’intervalle. Une fois la fonction \texttt{lireEntier} testée, utilisez dans un programme qui calcule et affiche les minimum, maximum et la moyenne de 10 entiers dans l'intervalle –1000 et 1000 saisis par l'utilisateur. Pour ce faire, vous devez définir les fonctions suivantes :
%
% \begin{itemize}
% \item \texttt{void remplirTableau(int desEntiers[], int nombreElementsTableau)} :
%
% qui rempli le tableau d'entiers appelé desEntiers, à partir des données saisies par l'utilisateur (utilisation de lireEntier()).
%
% \item \texttt{int max(int desEntiers[], int nombreElementsTableau)} :
%
% retourne le maximum du tableau desEntiers.
%
% \item \texttt{int min(int desEntiers[], int nombreElementsTableau)} :
%
% retourne le minimum du tableau desEntiers.
%
% \item \texttt{int moyenne(int desEntiers[], int nombreElementsTableau)} :
%
% retourne le moyenne du tableau desEntiers.
%
% \end{itemize}
%
% \item Écrire un programme permettant de réaliser la somme et le produit scalaire de 2 vecteurs de réels. Pour ce faire, n vecteur sera représenté par un tableau de 3 éléments. Définissez au moins les fonctions suivantes :
%
% \begin{itemize}
% \item \texttt{void afficher(float v[])} : affiche le vecteur v sous la forme : (v0 v1 v2) où v0, v1 et v2 sont les éléments du vecteur v.
% \item \texttt{float produitScalaire(float a[], float b[])} : retourne un réel résultat du produit scalaire des vecteurs a et b. Rappel : Soit le vecteur a = (a1 a1 a2) et b = (b0 b1 b2). Le produit scalaire de a et b égale a0*b0+a1*b1+a2*b2.
% \item \texttt{float * nouveauVecteur()} : Alloue la mémoire pour un nouveau vecteur et le rempli en demandant les éléments à l’utilisateur. Retourne un pointeur sur le nouveau vecteur
% \item \texttt{float * somme(float a[], float b[])} : Calcule la somme des deux vecteurs a et b, puis retourne un pointeur sur le vecteur résultat. a+b = (a0+b0   a1+b1   a2+b2).
% \end{itemize}
% NOTE : N’oubliez pas de libérer toute mémoire allouée !
%
% \item Étendez le programme précédent afin de manipuler des vecteurs de taille quelconque.
%
%
%
% % \item Ecrivez (et testez) la fonction \texttt{void dessinerGrille(int nbreLignes, int nbreColonnes)} qui dessine une grille. Les nombres de colonnes et de lignes sont donnés par l’utilisateur. Pour dessiner, utilisez les caractères: '|' et  '\_' complétés par des blancs chaque fois que nécessaire (première ligne).
% % Exemple d’une grille 2 linges 3 colonnes :
% % \begin{verbatim}
% %     _ _ _
% %    |_|_|_|
% %    |_|_|_|
% % \end{verbatim}
%
%       \item \textbf{Ordre lexicographique}\\
%    Écrire une fonction qui étant donné deux chaînes de caractères \texttt{s1} et \texttt{s2} qui renvoie un entier négatif si \texttt{s1} est avant \texttt{s2} dans l'ordre lexicographique (ordre du dictionnaire), 0 si \texttt{s1 == s2} et un entier positif sinon. On supposera que la fin des chaînes \texttt{s1} et \texttt{s2} est marquée par le caractère \verb+'\0'+. Le prototype de cette fonction est: \\
%    \texttt{int compare\_chaine(char s1[], char s2[])}\\
%    Faites une version récursive et une version itérative.
%
%    Note: Dans la suite, vous pouvez utiliser la fonction \texttt{strcmp} de la bibliothèque \texttt{string.h} qui permet la comparaison de chaînes de caractères (cf. documentation).
%
%    \item \textbf{Recherche de sous-chaîne}\\
%    Écrire une fonction recherchant si une chaîne de caractères $motif$ est présente dans une autre chaîne $texte$ en n'utilisant que des comparaisons de caractères.
%
%    \item \textbf{Recherche dichotomique}\\
%    Etant donné un tableau T indicé par des entiers et dont les éléments sont des entiers, ordonné par ordre croissant, rechercher par dichotomie si un entier X figure dans T.
%
%    % \item On considère un tableau T de N valeurs entières. X est une valeur entière. On calcule la somme des premiers éléments du tableau et on veut afficher le premier indice (s'il existe) pour lequel cette somme devient supérieure ou égale à X. On recommence ensuite ce travail sur le reste du tableau.  Ecrire un programme réalisant ce travail. \\
%    % Exemple: si $T=(4,2,1,-3,5,7,2)$ et $X=5$, on obtient les indices 1 et 5 (le tableau étant indicé de 0 à N)
%
%    % \item \emph{Codage?}\\
%    % Soit un tableau T de caractères de taille 26. Ecrire un programme qui vérifie que le tableau est un codage. (On dira qu'un tableau est un codage si chaque lettre de l'alphabet appartient au tableau).
%
%    % \item On dispose d'un tableau de N entiers positifs. On souhaite disposer d'une fonction qui, étant donné ce tableau et un entier positif P retourne I le plus petit indice tel que tous les entiers de 1 à P figurent dans les I premiers éléments du tableau. S'il n'existe pas un tel indice, la fonction retourne N+1.\\
%    % Exemple : pour le tableau dont les éléments sont (1,8,3,5,6,3,2,5,3), l'appel de la fonction avec la valeur 3 pour le paramètre P retourne la valeur 6. L'appel avec la valeur 5 pour le paramètre P retourne la valeur 10.\\
%    % Plusieurs idées d'algorithmes sont imaginables. Vous pouvez exploiter le fait que, dans l'utilisation que vous allez en faire, N est très supérieur à P.
%
\end{document}